# -*- coding: utf-8 -*-
"""AI Applications of Comprehensions, Lambdas, & Decorators

Automatically generated by Colab.

"""

## List comprehensions

# Traditional loop
squares = []
for x in range(10):
    squares.append(x**2)
print(f'Loop: {squares}')

# List comprehension
squares = [x**2 for x in range(10)]
print(f'Comprehension: {squares}')

"""### Example: Preprocessing Text Data"""

# Preprocessing text data
words = ["Hello", "World", "AI", "Python"]
word_lengths = [len(word) for word in words]
print(word_lengths)

# Feature extraction
features = [
    [1 if char in word.lower() else 0 for char in 'aeiou']
    for word in words
]
print(features)

# Data normalization
data = [10, 25, 5, 15, 20]
normalized = [(x - min(data)) / (max(data) - min(data))
              for x in data]
print(normalized)

"""## Lambda Functions"""

# Traditional function
def square(x):
    return x**2

# Lambda function
square = lambda x: x**2

# Map example - applying function to all elements
numbers = [1, -2, 3, -4, 5]
squared = list(map(lambda x: x**3, numbers))

# Filter example - selecting elements
positive = list(filter(lambda x: x > 0, numbers))

print (squared)
print (positive)

"""## Examples from AI"""

quote = "      Whatever this is that I am, it is flesh and a little spirit and an intelligence.      "
# Feature scaling
scale = lambda x: (x - x.mean()) / x.std()

# Custom activation function
relu = lambda x: max(0, x)

# Text preprocessing
clean_text = lambda text: text.lower().strip()

print(clean_text(quote))
clean_text

"""## Decorators"""

def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

"""### Decorator with arguments"""

def timer(func):
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        result = func(*args, **kwargs)
        print(f"Function took {time.time() - start:.2f} seconds")
        return result
    return wrapper

@timer
def train_model(data):
    # Simulate some work
    sum = 0
    for i in range(1000000):
        sum += i
    return sum

data = None  # dummy data
result = train_model(data)
print(f"Result: {result}")

def batch_generator(data, batch_size=32):
    """Generate batches of data for training"""
    for i in range(0, len(data), batch_size):
        yield data[i:i + batch_size]

# Test data
training_data = list(range(35))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for batch in batch_generator(training_data, batch_size=6):
    print(f"Processing batch: {batch}")

"""## Generators"""

# Generator expression (memory-efficient, lazy evaluation)

squares_gen = (x**2 for x in range(10))
print(f'Generator: {squares_gen}')       # This prints the generator object
print(f'Consumed: {list(squares_gen)}')  # Convert to a list

"""### Generator function"""

def square_gen(n):
    for x in range(n):
        gen = square_gen(10)

    print(f'From function: {list(gen)}')

"""### Example: Data Processing in AI"""

"""### Infinite data stream simulation"""

def infinite_sequence(start=0):
    num = start
    while True:
        yield num
        num += 1

seq = infinite_sequence()
print(f'First few: {next(seq)}, {next(seq)}, {next(seq)}')
print("Print 3 more: ")
for _ in range(3):
    print(next(seq))
print(f'And a few more: {next(seq)}, {next(seq)}, {next(seq)}')

"""### Batch generatator for training data (useful for ML pipelines)"""

def batch_generator(data, batch_size=32):
    """Generate batches of data for training"""
    for i in range(0, len(data), batch_size):
       yield data[i:i + batch_size]

# Test data
training_data = list(range(35))  # [0, 1, 2, ..., 34]
for batch in batch_generator(training_data, batch_size=6):
    print(f"Processing batch: {batch}")

# Memory-efficient data loading (e.g., large datasets)
large_data = range(1000000)  # Simulate large dataset
batches = batch_generator(large_data, batch_size=100)
first_batch = next(batches)
print(f"First batch sum: {sum(first_batch)}")
print(f"Next batch sum: {sum(next(batches))}")